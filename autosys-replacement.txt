---

## AutoSys Migration Tool

### File: src/AutoSys.Migration/AutoSys.Migration.csproj
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net7.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="7.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="7.0.0" />
    <PackageReference Include="System.CommandLine" Version="2.0.0-beta4.22272.1" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AutoSys.Models\AutoSys.Models.csproj" />
  </ItemGroup>
</Project>
```

### File: src/AutoSys.Migration/JilParser.cs
```csharp
using AutoSys.Models;
using ConsoleExecutor.Common.Models;
using System.Text.RegularExpressions;

namespace AutoSys.Migration;

/// <summary>
/// Parses AutoSys JIL (Job Information Language) files and converts to BoxDefinition
/// </summary>
public class JilParser
{
    public static List<BoxDefinition> ParseJilFile(string filePath)
    {
        var jilContent = File.ReadAllText(filePath);
        var boxes = new List<BoxDefinition>();
        
        // Split JIL content into individual job definitions
        var jobBlocks = SplitIntoJobBlocks(jilContent);
        
        // Group jobs by box
        var jobsByBox = new Dictionary<string, List<JobDefinition>>();
        var boxJobs = new List<JobDefinition>();
        
        foreach (var block in jobBlocks)
        {
            var job = ParseJobBlock(block);
            if (job != null)
            {
                if (IsBoxDefinition(block))
                {
                    // This is a box - create box definition
                    var boxId = ExtractJobName(block);
                    var boxDef = CreateBoxFromJil(block, boxId);
                    boxes.Add(boxDef);
                }
                else
                {
                    // This is a regular job
                    boxJobs.Add(job);
                }
            }
        }
        
        // If no explicit boxes found, create a default box with all jobs
        if (!boxes.Any() && boxJobs.Any())
        {
            boxes.Add(new BoxDefinition
            {
                BoxId = "MIGRATED_JOBS",
                Name = "Migrated AutoSys Jobs",
                Description = "Jobs migrated from AutoSys",
                Jobs = boxJobs
            });
        }
        
        return boxes;
    }
    
    private static List<string> SplitIntoJobBlocks(string jilContent)
    {
        var blocks = new List<string>();
        var lines = jilContent.Split('\n');
        var currentBlock = new List<string>();
        
        foreach (var line in lines)
        {
            if (line.Trim().StartsWith("insert_job:") || line.Trim().StartsWith("update_job:"))
            {
                if (currentBlock.Any())
                {
                    blocks.Add(string.Join('\n', currentBlock));
                    currentBlock.Clear();
                }
            }
            
            currentBlock.Add(line);
        }
        
        if (currentBlock.Any())
        {
            blocks.Add(string.Join('\n', currentBlock));
        }
        
        return blocks;
    }
    
    private static JobDefinition? ParseJobBlock(string block)
    {
        try
        {
            var jobName = ExtractJobName(block);
            if (string.IsNullOrEmpty(jobName))
                return null;
                
            var command = ExtractCommand(block);
            var condition = ExtractCondition(block);
            var description = ExtractDescription(block);
            
            // Parse command into executable and arguments
            var (executable, arguments) = ParseCommand(command);
            
            return new JobDefinition
            {
                JobId = jobName,
                Name = jobName,
                Description = description ?? "",
                ExecutionParameters = new ConsoleAppParameters
                {
                    ExecutablePath = executable,
                    Arguments = arguments,
                    TimeoutSeconds = 3600, // Default 1 hour
                    CaptureOutput = true,
                    CaptureError = true
                },
                Dependencies = ExtractDependencies(block),
                Conditions = ExtractConditions(block),
                RetryPolicy = new JobRetryPolicy
                {
                    MaxAttempts = ExtractMaxRuns(block)
                }
            };
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error parsing job block: {ex.Message}");
            return null;
        }
    }
    
    private static string ExtractJobName(string block)
    {
        var match = Regex.Match(block, @"insert_job:\s*(\w+)|update_job:\s*(\w+)", RegexOptions.IgnoreCase);
        return match.Success ? (match.Groups[1].Value ?? match.Groups[2].Value) : "";
    }
    
    private static string ExtractCommand(string block)
    {
        var match = Regex.Match(block, @"command:\s*(.+)", RegexOptions.IgnoreCase);
        return match.Success ? match.Groups[1].Value.Trim() : "";
    }
    
    private static string? ExtractDescription(string block)
    {
        var match = Regex.Match(block, @"description:\s*[""'](.+?)[""']", RegexOptions.IgnoreCase);
        return match.Success ? match.Groups[1].Value : null;
    }
    
    private static string ExtractCondition(string block)
    {
        var match = Regex.Match(block, @"condition:\s*(.+)", RegexOptions.IgnoreCase);
        return match.Success ? match.Groups[1].Value.Trim() : "";
    }
    
    private static (string executable, string arguments) ParseCommand(string command)
    {
        if (string.IsNullOrEmpty(command))
            return ("", "");
            
        // Remove quotes and split command
        command = command.Trim('"', '\'');
        var parts = command.Split(' ', 2, StringSplitOptions.RemoveEmptyEntries);
        
        if (parts.Length == 1)
            return (parts[0], "");
        else
            return (parts[0], parts[1]);
    }
    
    private static List<string> ExtractDependencies(string block)
    {
        var dependencies = new List<string>();
        var conditionLine = ExtractCondition(block);
        
        if (!string.IsNullOrEmpty(conditionLine))
        {
            // Parse AutoSys conditions like "s(JOB1) & s(JOB2)"
            var matches = Regex.Matches(conditionLine, @"s\((\w+)\)", RegexOptions.IgnoreCase);
            foreach (Match match in matches)
            {
                dependencies.Add(match.Groups[1].Value);
            }
        }
        
        return dependencies;
    }
    
    private static List<JobCondition> ExtractConditions(string block)
    {
        var conditions = new List<JobCondition>();
        var conditionLine = ExtractCondition(block);
        
        if (!string.IsNullOrEmpty(conditionLine))
        {
            // Parse file conditions like "f(/path/to/file)"
            var fileMatches = Regex.Matches(conditionLine, @"f\(([^)]+)\)", RegexOptions.IgnoreCase);
            foreach (Match match in fileMatches)
            {
                conditions.Add(new JobCondition
                {
                    Type = ConditionType.FileExists,
                    Expression = match.Groups[1].Value
                });
            }
        }
        
        return conditions;
    }
    
    private static int ExtractMaxRuns(string block)
    {
        var match = Regex.Match(block, @"max_run_alarm:\s*(\d+)", RegexOptions.IgnoreCase);
        return match.Success ? int.Parse(match.Groups[1].Value) : 3;
    }
    
    private static bool IsBoxDefinition(string block)
    {
        return Regex.IsMatch(block, @"job_type:\s*b", RegexOptions.IgnoreCase);
    }
    
    private static BoxDefinition CreateBoxFromJil(string block, string boxId)
    {
        var description = ExtractDescription(block);
        
        return new BoxDefinition
        {
            BoxId = boxId,
            Name = boxId,
            Description = description ?? $"Migrated AutoSys box: {boxId}",
            Jobs = new List<JobDefinition>(), // Jobs will be added separately
            FailureHandling = FailureHandling.StopBox
        };
    }
}
```

---

## Migration CLI Tool

### File: src/AutoSys.Migration/Program.cs
```csharp
using AutoSys.Migration;
using System.CommandLine;
using System.Text.Json;

var rootCommand = new RootCommand("AutoSys to Temporal Migration Tool");

// JIL file migration command
var migrateCommand = new Command("migrate", "Migrate AutoSys JIL file to Temporal box definitions");
var jilFileOption = new Option<FileInfo>("--jil-file", "Path to AutoSys JIL file") { IsRequired = true };
var outputOption = new Option<DirectoryInfo>("--output", "Output directory for box definitions") { IsRequired = true };

migrateCommand.AddOption(jilFileOption);
migrateCommand.AddOption(outputOption);

migrateCommand.SetHandler(async (FileInfo jilFile, DirectoryInfo outputDir) =>
{
    try
    {
        Console.WriteLine($"Migrating JIL file: {jilFile.FullName}");
        
        if (!jilFile.Exists)
        {
            Console.WriteLine("JIL file not found!");
            return;
        }
        
        // Parse JIL file
        var boxes = JilParser.ParseJilFile(jilFile.FullName);
        
        // Create output directory
        outputDir.Create();
        
        // Save each box definition
        foreach (var box in boxes)
        {
            var outputFile = Path.Combine(outputDir.FullName, $"{box.BoxId}.json");
            var json = JsonSerializer.Serialize(box, new JsonSerializerOptions 
            { 
                WriteIndented = true 
            });
            
            await File.WriteAllTextAsync(outputFile, json);
            Console.WriteLine($"Created box definition: {outputFile}");
        }
        
        Console.WriteLine($"Migration completed! Created {boxes.Count} box definitions.");
        
        // Generate summary report
        await GenerateMigrationReport(boxes, outputDir.FullName);
        
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Migration failed: {ex.Message}");
    }
}, jilFileOption, outputOption);

// Schedule migration command
var scheduleCommand = new Command("create-schedules", "Create schedule definitions from cron expressions");
var scheduleFileOption = new Option<FileInfo>("--schedule-file", "CSV file with schedule definitions") { IsRequired = true };
var scheduleOutputOption = new Option<DirectoryInfo>("--output", "Output directory for schedule definitions") { IsRequired = true };

scheduleCommand.AddOption(scheduleFileOption);
scheduleCommand.AddOption(scheduleOutputOption);

scheduleCommand.SetHandler(async (FileInfo scheduleFile, DirectoryInfo outputDir) =>
{
    // Implementation for schedule migration
    Console.WriteLine("Schedule migration not implemented yet");
}, scheduleFileOption, scheduleOutputOption);

rootCommand.AddCommand(migrateCommand);
rootCommand.AddCommand(scheduleCommand);

return await rootCommand.InvokeAsync(args);

static async Task GenerateMigrationReport(List<BoxDefinition> boxes, string outputDir)
{
    var reportPath = Path.Combine(outputDir, "migration-report.md");
    var report = new System.Text.StringBuilder();
    
    report.AppendLine("# AutoSys Migration Report");
    report.AppendLine($"Generated: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
    report.AppendLine();
    
    report.AppendLine($"## Summary");
    report.AppendLine($"- Total Boxes: {boxes.Count}");
    report.AppendLine($"- Total Jobs: {boxes.Sum(b => b.Jobs.Count)}");
    report.AppendLine();
    
    foreach (var box in boxes)
    {
        report.AppendLine($"## Box: {box.BoxId}");
        report.AppendLine($"- **Name**: {box.Name}");
        report.AppendLine($"- **Description**: {box.Description}");
        report.AppendLine($"- **Jobs**: {box.Jobs.Count}");
        report.AppendLine();
        
        if (box.Jobs.Any())
        {
            report.AppendLine("### Jobs:");
            foreach (var job in box.Jobs)
            {
                report.AppendLine($"- **{job.JobId}**: {job.ExecutionParameters.ExecutablePath} {job.ExecutionParameters.Arguments}");
                if (job.Dependencies.Any())
                {
                    report.AppendLine($"  - Dependencies: {string.Join(", ", job.Dependencies)}");
                }
            }
            report.AppendLine();
        }
    }
    
    await File.WriteAllTextAsync(reportPath, report.ToString());
    Console.WriteLine($"Migration report created: {reportPath}");
}
```

---

## Deployment Guide

### Complete Docker Setup

Create an enhanced `docker-compose.yml` for the full AutoSys replacement:

```yaml
version: '3.8'

services:
  # Temporal Server
  temporal:
    image: temporalio/auto-setup:latest
    container_name: temporal-server
    environment:
      - DB=postgresql
      - DB_PORT=5432
      - POSTGRES_USER=temporal
      - POSTGRES_PWD=temporal
      - POSTGRES_SEEDS=postgresql
      - DYNAMIC_CONFIG_FILE_PATH=config/dynamicconfig/development-sql.yaml
    ports:
      - "7233:7233"   # Temporal gRPC
      - "8233:8233"   # Temporal Web UI
    depends_on:
      - postgresql
    networks:
      - temporal-network

  # PostgreSQL for Temporal
  postgresql:
    image: postgres:13
    container_name: temporal-postgresql
    environment:
      - POSTGRES_PASSWORD=temporal
      - POSTGRES_USER=temporal
      - POSTGRES_DB=temporal
    volumes:
      - temporal-postgresql:/var/lib/postgresql/data
    networks:
      - temporal-network

  # AutoSys Replacement Worker
  autosys-worker:
    build:
      context: .
      dockerfile: Dockerfile.AutoSys
    container_name: autosys-replacement-worker
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
      - Temporal__TargetHost=temporal:7233
      - Temporal__Namespace=default
      - Temporal__TaskQueue=autosys-replacement-queue
    volumes:
      # Console applications
      - ./console-apps:/app/console-apps:ro
      - ./box-definitions:/app/box-definitions
      - ./shared-data:/app/shared-data
      - ./logs:/app/logs
    restart: unless-stopped
    depends_on:
      - temporal
    networks:
      - temporal-network

  # AutoSys Management Web API
  autosys-web:
    build:
      context: .
      dockerfile: Dockerfile.Web
    container_name: autosys-web-api
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
      - Temporal__TargetHost=temporal:7233
      - Temporal__Namespace=default
      - Temporal__TaskQueue=autosys-replacement-queue
    ports:
      - "5000:80"     # Web API
    depends_on:
      - temporal
      - autosys-worker
    networks:
      - temporal-network

  # Scheduler Worker (runs schedules)
  scheduler-worker:
    build:
      context: .
      dockerfile: Dockerfile.Scheduler
    container_name: autosys-scheduler
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
      - Temporal__TargetHost=temporal:7233
      - Temporal__Namespace=default
      - Temporal__TaskQueue=autosys-replacement-queue
    volumes:
      - ./schedules:/app/schedules
    restart: unless-stopped
    depends_on:
      - temporal
    networks:
      - temporal-network

volumes:
  temporal-postgresql:

networks:
  temporal-network:
    driver: bridge
```

### Migration Process

1. **Export AutoSys Jobs**:
```bash
# Export from AutoSys (example)
autorep -J ALL -q > autosys_jobs.jil
```

2. **Run Migration Tool**:
```bash
# Build migration tool
dotnet build src/AutoSys.Migration

# Migrate JIL to box definitions
dotnet run --project src/AutoSys.Migration -- migrate \
  --jil-file autosys_jobs.jil \
  --output ./box-definitions
```

3. **Deploy and Test**:
```bash
# Start the full stack
docker-compose up -d

# Create a test box via API
curl -X POST http://localhost:5000/api/box \
  -H "Content-Type: application/json" \
  -d @box-definitions/DAILY_PROCESSING.json

# Run the box
curl -X POST http://localhost:5000/api/box/DAILY_PROCESSING/run
```

4. **Monitor Execution**:
- Temporal Web UI: http://localhost:8233
- AutoSys Web API: http://localhost:5000/swagger

---

## Key Advantages Over AutoSys

| Feature | AutoSys | Temporal Solution |
|---------|---------|-------------------|
| **Cost** | Expensive licensing | Open source, free |
| **UI** | Desktop client only | Web-based + API |
| **Monitoring** | Limited visibility | Real-time, detailed |
| **Scalability** | Single server | Distributed, cloud-native |
| **Integration** | Proprietary | REST API, standard protocols |
| **Version Control** | GUI-based | Code-based definitions |
| **Cloud Support** | Limited | Native cloud support |
| **Failure Recovery** | Basic | Advanced retry policies |
| **Dependencies** | Simple conditions | Complex workflow logic |
| **Extensibility** | Limited | Highly extensible |

---

## Migration Checklist

- [ ] **Export AutoSys definitions** using JIL export
- [ ] **Run migration tool** to convert JIL to JSON
- [ ] **Review migrated boxes** for accuracy
- [ ] **Set up console applications** in mounted volumes
- [ ] **Configure schedules** for automated execution
- [ ] **Test individual boxes** before going live
- [ ] **Set up monitoring** and alerting
- [ ] **Train team** on new web interface
- [ ] **Implement backup strategy** for box definitions
- [ ] **Plan rollback procedure** if needed

This framework gives you a complete AutoSys replacement that's more modern, cost-effective, and maintainable while preserving all your existing job logic!# AutoSys Replacement Using Temporal Framework

## Conceptual Mapping

| AutoSys Concept | Temporal Equivalent | Description |
|----------------|-------------------|-------------|
| **Box** | **Box Workflow** | Parent workflow that orchestrates multiple jobs |
| **Job** | **Job Activity** | Individual executable (C#/Python) wrapped as activity |
| **Job Dependencies** | **Workflow Logic** | Control flow and sequencing in workflow code |
| **Conditions** | **Workflow Conditions** | Runtime decision making |
| **Scheduling** | **Temporal Schedules** | Cron-like scheduling with Temporal's scheduler |
| **Job Streams** | **Workflow Chains** | Sequences of related boxes/workflows |

---

## Enhanced Framework Architecture

### Project Structure Extension
```
AutoSysReplacement/
├── src/
│   ├── ConsoleExecutor.Common/           # Existing
│   ├── ConsoleExecutor.Activities/       # Existing  
│   ├── ConsoleExecutor.Workflows/        # Existing
│   ├── AutoSys.Models/                   # NEW: AutoSys domain models
│   ├── AutoSys.Workflows/                # NEW: Box and job stream workflows
│   ├── AutoSys.Activities/               # NEW: Enhanced job activities
│   ├── AutoSys.Scheduler/                # NEW: Schedule management
│   ├── AutoSys.Web/                      # NEW: Web UI for job management
│   └── AutoSys.Migration/                # NEW: AutoSys definition import
```

---

## Core Models

### File: src/AutoSys.Models/AutoSys.Models.csproj
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net7.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\ConsoleExecutor.Common\ConsoleExecutor.Common.csproj" />
  </ItemGroup>
</Project>
```

### File: src/AutoSys.Models/BoxDefinition.cs
```csharp
namespace AutoSys.Models;

/// <summary>
/// Represents an AutoSys Box - a container for related jobs
/// </summary>
public record BoxDefinition
{
    /// <summary>
    /// Unique identifier for the box
    /// </summary>
    public string BoxId { get; init; } = string.Empty;
    
    /// <summary>
    /// Human-readable name for the box
    /// </summary>
    public string Name { get; init; } = string.Empty;
    
    /// <summary>
    /// Description of what this box does
    /// </summary>
    public string Description { get; init; } = string.Empty;
    
    /// <summary>
    /// Jobs contained in this box
    /// </summary>
    public List<JobDefinition> Jobs { get; init; } = new();
    
    /// <summary>
    /// Box-level environment variables
    /// </summary>
    public Dictionary<string, string> EnvironmentVariables { get; init; } = new();
    
    /// <summary>
    /// Maximum time for the entire box to complete
    /// </summary>
    public TimeSpan MaxDuration { get; init; } = TimeSpan.FromHours(4);
    
    /// <summary>
    /// What to do if a job fails
    /// </summary>
    public FailureHandling FailureHandling { get; init; } = FailureHandling.StopBox;
    
    /// <summary>
    /// Retry policy for the entire box
    /// </summary>
    public BoxRetryPolicy RetryPolicy { get; init; } = new();
    
    /// <summary>
    /// Notification settings
    /// </summary>
    public NotificationSettings Notifications { get; init; } = new();
}

public enum FailureHandling
{
    StopBox,        // Stop entire box on first job failure
    ContinueBox,    // Continue with remaining jobs
    RetryJob,       // Retry failed job, then continue
    SkipJob         // Skip failed job and continue
}

public record BoxRetryPolicy
{
    public int MaxAttempts { get; init; } = 1;
    public TimeSpan InitialDelay { get; init; } = TimeSpan.FromMinutes(1);
    public TimeSpan MaxDelay { get; init; } = TimeSpan.FromMinutes(10);
    public double BackoffMultiplier { get; init; } = 2.0;
}
```

### File: src/AutoSys.Models/JobDefinition.cs
```csharp
using ConsoleExecutor.Common.Models;

namespace AutoSys.Models;

/// <summary>
/// Represents an individual job within a box
/// </summary>
public record JobDefinition
{
    /// <summary>
    /// Unique identifier for the job within the box
    /// </summary>
    public string JobId { get; init; } = string.Empty;
    
    /// <summary>
    /// Human-readable name
    /// </summary>
    public string Name { get; init; } = string.Empty;
    
    /// <summary>
    /// Job description
    /// </summary>
    public string Description { get; init; } = string.Empty;
    
    /// <summary>
    /// Console application parameters
    /// </summary>
    public ConsoleAppParameters ExecutionParameters { get; init; } = new();
    
    /// <summary>
    /// Jobs that must complete successfully before this job runs
    /// </summary>
    public List<string> Dependencies { get; init; } = new();
    
    /// <summary>
    /// Conditions that must be met for this job to run
    /// </summary>
    public List<JobCondition> Conditions { get; init; } = new();
    
    /// <summary>
    /// Job-specific retry policy
    /// </summary>
    public JobRetryPolicy RetryPolicy { get; init; } = new();
    
    /// <summary>
    /// Whether this job can run in parallel with others
    /// </summary>
    public bool AllowParallelExecution { get; init; } = true;
    
    /// <summary>
    /// Priority (1-10, higher number = higher priority)
    /// </summary>
    public int Priority { get; init; } = 5;
    
    /// <summary>
    /// Job-specific environment variables
    /// </summary>
    public Dictionary<string, string> EnvironmentVariables { get; init; } = new();
    
    /// <summary>
    /// What to do when this job completes successfully
    /// </summary>
    public List<JobAction> OnSuccess { get; init; } = new();
    
    /// <summary>
    /// What to do when this job fails
    /// </summary>
    public List<JobAction> OnFailure { get; init; } = new();
}

public record JobCondition
{
    public ConditionType Type { get; init; }
    public string Expression { get; init; } = string.Empty;
    public Dictionary<string, object> Parameters { get; init; } = new();
}

public enum ConditionType
{
    FileExists,
    FileSize,
    TimeWindow,
    DatabaseQuery,
    ApiCall,
    Custom
}

public record JobRetryPolicy
{
    public int MaxAttempts { get; init; } = 3;
    public TimeSpan InitialDelay { get; init; } = TimeSpan.FromSeconds(30);
    public TimeSpan MaxDelay { get; init; } = TimeSpan.FromMinutes(5);
    public double BackoffMultiplier { get; init; } = 1.5;
    public List<string> RetryableExitCodes { get; init; } = new() { "1", "2" };
}

public record JobAction
{
    public ActionType Type { get; init; }
    public Dictionary<string, object> Parameters { get; init; } = new();
}

public enum ActionType
{
    SendEmail,
    SendSlack,
    CreateFile,
    CallWebhook,
    TriggerWorkflow,
    UpdateDatabase
}
```

### File: src/AutoSys.Models/ScheduleDefinition.cs
```csharp
namespace AutoSys.Models;

/// <summary>
/// Represents scheduling information for boxes
/// </summary>
public record ScheduleDefinition
{
    /// <summary>
    /// Unique schedule identifier
    /// </summary>
    public string ScheduleId { get; init; } = string.Empty;
    
    /// <summary>
    /// Box to schedule
    /// </summary>
    public string BoxId { get; init; } = string.Empty;
    
    /// <summary>
    /// Cron expression for scheduling
    /// </summary>
    public string CronExpression { get; init; } = string.Empty;
    
    /// <summary>
    /// Time zone for the schedule
    /// </summary>
    public string TimeZone { get; init; } = "UTC";
    
    /// <summary>
    /// Whether the schedule is active
    /// </summary>
    public bool IsActive { get; init; } = true;
    
    /// <summary>
    /// Start date for the schedule
    /// </summary>
    public DateTime? StartDate { get; init; }
    
    /// <summary>
    /// End date for the schedule
    /// </summary>
    public DateTime? EndDate { get; init; }
    
    /// <summary>
    /// Calendar to use for scheduling (holidays, etc.)
    /// </summary>
    public string? Calendar { get; init; }
    
    /// <summary>
    /// What to do if previous run is still running
    /// </summary>
    public OverlapPolicy OverlapPolicy { get; init; } = OverlapPolicy.Skip;
}

public enum OverlapPolicy
{
    Skip,           // Skip if previous run still running
    Queue,          // Queue up and run when current completes
    Terminate,      // Terminate previous run and start new one
    AllowOverlap    // Allow multiple concurrent runs
}
```

### File: src/AutoSys.Models/NotificationSettings.cs
```csharp
namespace AutoSys.Models;

public record NotificationSettings
{
    /// <summary>
    /// Email addresses to notify
    /// </summary>
    public List<string> EmailAddresses { get; init; } = new();
    
    /// <summary>
    /// Slack channels to notify
    /// </summary>
    public List<string> SlackChannels { get; init; } = new();
    
    /// <summary>
    /// When to send notifications
    /// </summary>
    public NotificationTriggers Triggers { get; init; } = new();
}

public record NotificationTriggers
{
    public bool OnStart { get; init; } = false;
    public bool OnSuccess { get; init; } = true;
    public bool OnFailure { get; init; } = true;
    public bool OnRetry { get; init; } = false;
    public bool OnTimeout { get; init; } = true;
}
```

---

## Box Workflow Implementation

### File: src/AutoSys.Workflows/AutoSys.Workflows.csproj
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net7.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Temporalio" Version="1.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AutoSys.Models\AutoSys.Models.csproj" />
    <ProjectReference Include="..\ConsoleExecutor.Common\ConsoleExecutor.Common.csproj" />
  </ItemGroup>
</Project>
```

### File: src/AutoSys.Workflows/BoxWorkflow.cs
```csharp
using AutoSys.Models;
using ConsoleExecutor.Common.Models;
using Temporalio.Workflows;

namespace AutoSys.Workflows;

/// <summary>
/// Workflow that represents an AutoSys Box - orchestrates multiple jobs
/// </summary>
[Workflow]
public class BoxWorkflow
{
    // State
    private BoxDefinition _boxDefinition = null!;
    private Dictionary<string, JobExecutionState> _jobStates = new();
    private DateTime _startTime;
    private BoxExecutionStatus _status = BoxExecutionStatus.Pending;
    private string _currentPhase = "Initializing";

    /// <summary>
    /// Query to get current box status
    /// </summary>
    [WorkflowQuery]
    public BoxExecutionStatus GetStatus() => _status;

    /// <summary>
    /// Query to get job states
    /// </summary>
    [WorkflowQuery]
    public Dictionary<string, JobExecutionState> GetJobStates() => _jobStates;

    /// <summary>
    /// Query to get current execution phase
    /// </summary>
    [WorkflowQuery]
    public string GetCurrentPhase() => _currentPhase;

    /// <summary>
    /// Query to get execution summary
    /// </summary>
    [WorkflowQuery]
    public BoxExecutionSummary GetExecutionSummary() => new()
    {
        BoxId = _boxDefinition?.BoxId ?? "Unknown",
        Status = _status,
        StartTime = _startTime,
        CurrentPhase = _currentPhase,
        TotalJobs = _jobStates.Count,
        CompletedJobs = _jobStates.Values.Count(j => j.Status == JobStatus.Success),
        FailedJobs = _jobStates.Values.Count(j => j.Status == JobStatus.Failed),
        RunningJobs = _jobStates.Values.Count(j => j.Status == JobStatus.Running)
    };

    /// <summary>
    /// Signal to pause box execution
    /// </summary>
    [WorkflowSignal]
    public async Task PauseExecution()
    {
        Workflow.Logger.Info("Received pause signal for box {BoxId}", _boxDefinition.BoxId);
        _status = BoxExecutionStatus.Paused;
        await Task.CompletedTask;
    }

    /// <summary>
    /// Signal to resume box execution
    /// </summary>
    [WorkflowSignal]
    public async Task ResumeExecution()
    {
        Workflow.Logger.Info("Received resume signal for box {BoxId}", _boxDefinition.BoxId);
        if (_status == BoxExecutionStatus.Paused)
        {
            _status = BoxExecutionStatus.Running;
        }
        await Task.CompletedTask;
    }

    /// <summary>
    /// Signal to cancel box execution
    /// </summary>
    [WorkflowSignal]
    public async Task CancelExecution()
    {
        Workflow.Logger.Info("Received cancel signal for box {BoxId}", _boxDefinition.BoxId);
        _status = BoxExecutionStatus.Cancelled;
        await Task.CompletedTask;
    }

    /// <summary>
    /// Main workflow execution method
    /// </summary>
    [WorkflowRun]
    public async Task<BoxExecutionResult> RunAsync(BoxDefinition boxDefinition)
    {
        _boxDefinition = boxDefinition;
        _startTime = Workflow.UtcNow;
        _status = BoxExecutionStatus.Running;

        Workflow.Logger.Info(
            "Starting box execution: {BoxId} with {JobCount} jobs",
            boxDefinition.BoxId,
            boxDefinition.Jobs.Count);

        try
        {
            // Initialize job states
            foreach (var job in boxDefinition.Jobs)
            {
                _jobStates[job.JobId] = new JobExecutionState
                {
                    JobId = job.JobId,
                    Status = JobStatus.Pending,
                    StartTime = null,
                    EndTime = null
                };
            }

            // Execute the box using the specified strategy
            var result = await ExecuteBoxAsync();
            
            _status = result.Success ? BoxExecutionStatus.Success : BoxExecutionStatus.Failed;
            return result;
        }
        catch (Exception ex)
        {
            _status = BoxExecutionStatus.Failed;
            Workflow.Logger.Error(ex, "Box execution failed: {BoxId}", boxDefinition.BoxId);
            throw;
        }
    }

    private async Task<BoxExecutionResult> ExecuteBoxAsync()
    {
        var results = new List<JobExecutionResult>();
        var dependencyGraph = BuildDependencyGraph();
        
        _currentPhase = "Executing Jobs";

        // Execute jobs based on dependencies
        var completedJobs = new HashSet<string>();
        var failedJobs = new HashSet<string>();

        while (completedJobs.Count + failedJobs.Count < _boxDefinition.Jobs.Count)
        {
            // Check for cancellation or pause
            if (_status == BoxExecutionStatus.Cancelled)
            {
                break;
            }

            while (_status == BoxExecutionStatus.Paused)
            {
                await Workflow.DelayAsync(TimeSpan.FromSeconds(5));
            }

            // Find jobs that are ready to run
            var readyJobs = GetReadyJobs(dependencyGraph, completedJobs, failedJobs);
            
            if (!readyJobs.Any())
            {
                // No jobs ready - either waiting for dependencies or all done
                if (HasRunningJobs())
                {
                    await Workflow.DelayAsync(TimeSpan.FromSeconds(1));
                    continue;
                }
                break; // All jobs completed or blocked
            }

            // Execute ready jobs (in parallel if allowed)
            var jobTasks = new List<Task<JobExecutionResult>>();
            
            foreach (var job in readyJobs)
            {
                if (job.AllowParallelExecution || jobTasks.Count == 0)
                {
                    jobTasks.Add(ExecuteJobAsync(job));
                }
                else
                {
                    // Sequential execution required
                    var result = await ExecuteJobAsync(job);
                    results.Add(result);
                    
                    if (result.Success)
                    {
                        completedJobs.Add(job.JobId);
                    }
                    else
                    {
                        failedJobs.Add(job.JobId);
                        if (_boxDefinition.FailureHandling == FailureHandling.StopBox)
                        {
                            break;
                        }
                    }
                }
            }

            // Wait for parallel jobs to complete
            if (jobTasks.Any())
            {
                var parallelResults = await Task.WhenAll(jobTasks);
                results.AddRange(parallelResults);

                foreach (var result in parallelResults)
                {
                    if (result.Success)
                    {
                        completedJobs.Add(result.JobId);
                    }
                    else
                    {
                        failedJobs.Add(result.JobId);
                        if (_boxDefinition.FailureHandling == FailureHandling.StopBox)
                        {
                            break;
                        }
                    }
                }
            }
        }

        _currentPhase = "Completed";

        return new BoxExecutionResult
        {
            BoxId = _boxDefinition.BoxId,
            Success = failedJobs.Count == 0 && _status != BoxExecutionStatus.Cancelled,
            StartTime = _startTime,
            EndTime = Workflow.UtcNow,
            JobResults = results,
            Status = _status
        };
    }

    private async Task<JobExecutionResult> ExecuteJobAsync(JobDefinition job)
    {
        _jobStates[job.JobId] = _jobStates[job.JobId] with 
        { 
            Status = JobStatus.Running,
            StartTime = Workflow.UtcNow
        };

        Workflow.Logger.Info("Starting job: {JobId}", job.JobId);

        try
        {
            // Check job conditions
            if (!await EvaluateJobConditions(job))
            {
                var skippedResult = new JobExecutionResult
                {
                    JobId = job.JobId,
                    Success = true, // Considered successful if conditions not met
                    Skipped = true,
                    StartTime = Workflow.UtcNow,
                    EndTime = Workflow.UtcNow,
                    Message = "Job skipped due to conditions not being met"
                };

                _jobStates[job.JobId] = _jobStates[job.JobId] with 
                { 
                    Status = JobStatus.Skipped,
                    EndTime = Workflow.UtcNow
                };

                return skippedResult;
            }

            // Execute the job using the console executor
            var executionResult = await Workflow.ExecuteActivityAsync(
                "ExecuteConsoleApplicationAsync",
                new object[] { job.ExecutionParameters },
                new()
                {
                    StartToCloseTimeout = TimeSpan.FromSeconds(job.ExecutionParameters.TimeoutSeconds + 30),
                    RetryPolicy = new()
                    {
                        MaximumAttempts = job.RetryPolicy.MaxAttempts,
                        InitialInterval = job.RetryPolicy.InitialDelay,
                        MaximumInterval = job.RetryPolicy.MaxDelay,
                        BackoffCoefficient = job.RetryPolicy.BackoffMultiplier
                    }
                });

            var jobResult = new JobExecutionResult
            {
                JobId = job.JobId,
                Success = executionResult.IsSuccess,
                StartTime = executionResult.StartTime,
                EndTime = executionResult.EndTime,
                ExitCode = executionResult.ExitCode,
                StandardOutput = executionResult.StandardOutput,
                StandardError = executionResult.StandardError,
                ExecutionTimeMs = executionResult.ExecutionTimeMs
            };

            _jobStates[job.JobId] = _jobStates[job.JobId] with 
            { 
                Status = jobResult.Success ? JobStatus.Success : JobStatus.Failed,
                EndTime = jobResult.EndTime,
                ExitCode = jobResult.ExitCode
            };

            // Execute post-job actions
            if (jobResult.Success)
            {
                await ExecuteJobActions(job.OnSuccess);
            }
            else
            {
                await ExecuteJobActions(job.OnFailure);
            }

            return jobResult;
        }
        catch (Exception ex)
        {
            Workflow.Logger.Error(ex, "Job execution failed: {JobId}", job.JobId);
            
            _jobStates[job.JobId] = _jobStates[job.JobId] with 
            { 
                Status = JobStatus.Failed,
                EndTime = Workflow.UtcNow,
                ErrorMessage = ex.Message
            };

            return new JobExecutionResult
            {
                JobId = job.JobId,
                Success = false,
                StartTime = _jobStates[job.JobId].StartTime ?? Workflow.UtcNow,
                EndTime = Workflow.UtcNow,
                ErrorMessage = ex.Message
            };
        }
    }

    private Dictionary<string, List<string>> BuildDependencyGraph()
    {
        var graph = new Dictionary<string, List<string>>();
        
        foreach (var job in _boxDefinition.Jobs)
        {
            graph[job.JobId] = job.Dependencies.ToList();
        }
        
        return graph;
    }

    private List<JobDefinition> GetReadyJobs(
        Dictionary<string, List<string>> dependencyGraph, 
        HashSet<string> completedJobs, 
        HashSet<string> failedJobs)
    {
        return _boxDefinition.Jobs
            .Where(job => 
                !completedJobs.Contains(job.JobId) && 
                !failedJobs.Contains(job.JobId) &&
                _jobStates[job.JobId].Status == JobStatus.Pending &&
                job.Dependencies.All(dep => completedJobs.Contains(dep)))
            .OrderByDescending(job => job.Priority)
            .ToList();
    }

    private bool HasRunningJobs()
    {
        return _jobStates.Values.Any(state => state.Status == JobStatus.Running);
    }

    private async Task<bool> EvaluateJobConditions(JobDefinition job)
    {
        foreach (var condition in job.Conditions)
        {
            var result = await Workflow.ExecuteActivityAsync(
                "EvaluateJobConditionAsync",
                new object[] { condition },
                new() { StartToCloseTimeout = TimeSpan.FromMinutes(1) });

            if (!result)
            {
                return false;
            }
        }
        return true;
    }

    private async Task ExecuteJobActions(List<JobAction> actions)
    {
        foreach (var action in actions)
        {
            try
            {
                await Workflow.ExecuteActivityAsync(
                    "ExecuteJobActionAsync",
                    new object[] { action },
                    new() { StartToCloseTimeout = TimeSpan.FromMinutes(2) });
            }
            catch (Exception ex)
            {
                Workflow.Logger.Warning(ex, "Job action failed: {ActionType}", action.Type);
                // Don't fail the job if an action fails
            }
        }
    }
}

// Supporting types
public enum BoxExecutionStatus
{
    Pending,
    Running,
    Paused,
    Success,
    Failed,
    Cancelled
}

public enum JobStatus
{
    Pending,
    Running,
    Success,
    Failed,
    Skipped
}

public record JobExecutionState
{
    public string JobId { get; init; } = string.Empty;
    public JobStatus Status { get; init; }
    public DateTime? StartTime { get; init; }
    public DateTime? EndTime { get; init; }
    public int? ExitCode { get; init; }
    public string? ErrorMessage { get; init; }
}

public record BoxExecutionSummary
{
    public string BoxId { get; init; } = string.Empty;
    public BoxExecutionStatus Status { get; init; }
    public DateTime StartTime { get; init; }
    public string CurrentPhase { get; init; } = string.Empty;
    public int TotalJobs { get; init; }
    public int CompletedJobs { get; init; }
    public int FailedJobs { get; init; }
    public int RunningJobs { get; init; }
}

public record BoxExecutionResult
{
    public string BoxId { get; init; } = string.Empty;
    public bool Success { get; init; }
    public DateTime StartTime { get; init; }
    public DateTime EndTime { get; init; }
    public List<JobExecutionResult> JobResults { get; init; } = new();
    public BoxExecutionStatus Status { get; init; }
}

public record JobExecutionResult
{
    public string JobId { get; init; } = string.Empty;
    public bool Success { get; init; }
    public bool Skipped { get; init; }
    public DateTime StartTime { get; init; }
    public DateTime EndTime { get; init; }
    public int ExitCode { get; init; }
    public string StandardOutput { get; init; } = string.Empty;
    public string StandardError { get; init; } = string.Empty;
    public long ExecutionTimeMs { get; init; }
    public string? ErrorMessage { get; init; }
    public string? Message { get; init; }
}
```

---

## Scheduling Component

### File: src/AutoSys.Scheduler/AutoSys.Scheduler.csproj
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net7.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Temporalio" Version="1.0.0" />
    <PackageReference Include="Cronos" Version="0.7.1" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AutoSys.Models\AutoSys.Models.csproj" />
  </ItemGroup>
</Project>
```

### File: src/AutoSys.Scheduler/SchedulerWorkflow.cs
```csharp
using AutoSys.Models;
using Temporalio.Workflows;

namespace AutoSys.Scheduler;

/// <summary>
/// Workflow that manages scheduling of boxes (replaces AutoSys scheduler)
/// </summary>
[Workflow]
public class SchedulerWorkflow
{
    private readonly Dictionary<string, ScheduleDefinition> _schedules = new();
    private readonly Dictionary<string, DateTime> _lastExecution = new();
    private readonly Dictionary<string, string> _runningWorkflows = new();

    [WorkflowQuery]
    public Dictionary<string, ScheduleDefinition> GetActiveSchedules() => _schedules;

    [WorkflowQuery]
    public Dictionary<string, DateTime> GetLastExecutions() => _lastExecution;

    [WorkflowQuery]
    public Dictionary<string, string> GetRunningWorkflows() => _runningWorkflows;

    [WorkflowSignal]
    public async Task AddSchedule(ScheduleDefinition schedule)
    {
        Workflow.Logger.Info("Adding schedule: {ScheduleId} for box: {BoxId}", 
            schedule.ScheduleId, schedule.BoxId);
        
        _schedules[schedule.ScheduleId] = schedule;
        await Task.CompletedTask;
    }

    [WorkflowSignal]
    public async Task RemoveSchedule(string scheduleId)
    {
        Workflow.Logger.Info("Removing schedule: {ScheduleId}", scheduleId);
        
        _schedules.Remove(scheduleId);
        _lastExecution.Remove(scheduleId);
        await Task.CompletedTask;
    }

    [WorkflowSignal]
    public async Task TriggerBox(string boxId, string reason = "Manual Trigger")
    {
        Workflow.Logger.Info("Manually triggering box: {BoxId}, Reason: {Reason}", boxId, reason);
        
        // Find box definition and trigger immediately
        await TriggerBoxExecution(boxId, reason);
    }

    [WorkflowRun]
    public async Task RunAsync()
    {
        Workflow.Logger.Info("Starting AutoSys Scheduler Workflow");

        while (true)
        {
            try
            {
                var currentTime = Workflow.UtcNow;
                
                // Check each active schedule
                foreach (var schedule in _schedules.Values.Where(s => s.IsActive))
                {
                    if (ShouldExecute(schedule, currentTime))
                    {
                        await HandleScheduledExecution(schedule, currentTime);
                    }
                }

                // Clean up completed workflows
                await CleanupCompletedWorkflows();

                // Wait 60 seconds before next check
                await Workflow.DelayAsync(TimeSpan.FromMinutes(1));
            }
            catch (Exception ex)
            {
                Workflow.Logger.Error(ex, "Error in scheduler loop");
                await Workflow.DelayAsync(TimeSpan.FromMinutes(1));
            }
        }
    }

    private bool ShouldExecute(ScheduleDefinition schedule, DateTime currentTime)
    {
        // Check if within date range
        if (schedule.StartDate.HasValue && currentTime < schedule.StartDate.Value)
            return false;
            
        if (schedule.EndDate.HasValue && currentTime > schedule.EndDate.Value)
            return false;

        // Check if enough time has passed since last execution
        if (_lastExecution.ContainsKey(schedule.ScheduleId))
        {
            var lastRun = _lastExecution[schedule.ScheduleId];
            var cronExpression = Cronos.CronExpression.Parse(schedule.CronExpression);
            var nextRun = cronExpression.GetNextOccurrence(lastRun);
            
            if (nextRun == null || currentTime < nextRun.Value)
                return false;
        }

        // Check overlap policy
        if (_runningWorkflows.ContainsKey(schedule.BoxId))
        {
            switch (schedule.OverlapPolicy)
            {
                case OverlapPolicy.Skip:
                    Workflow.Logger.Info("Skipping execution of {BoxId} - previous run still active", schedule.BoxId);
                    return false;
                case OverlapPolicy.Terminate:
                    // Cancel the running workflow
                    await CancelRunningWorkflow(schedule.BoxId);
                    break;
                case OverlapPolicy.Queue:
                    // For now, skip - could implement queuing later
                    return false;
                case OverlapPolicy.AllowOverlap:
                    // Allow multiple concurrent runs
                    break;
            }
        }

        return true;
    }

    private async Task HandleScheduledExecution(ScheduleDefinition schedule, DateTime currentTime)
    {
        try
        {
            Workflow.Logger.Info("Triggering scheduled execution: {ScheduleId} for box: {BoxId}", 
                schedule.ScheduleId, schedule.BoxId);

            await TriggerBoxExecution(schedule.BoxId, $"Scheduled execution: {schedule.ScheduleId}");
            _lastExecution[schedule.ScheduleId] = currentTime;
        }
        catch (Exception ex)
        {
            Workflow.Logger.Error(ex, "Failed to trigger scheduled execution: {ScheduleId}", schedule.ScheduleId);
        }
    }

    private async Task TriggerBoxExecution(string boxId, string reason)
    {
        // Get box definition
        var boxDefinition = await Workflow.ExecuteActivityAsync(
            "GetBoxDefinitionAsync",
            new object[] { boxId },
            new() { StartToCloseTimeout = TimeSpan.FromMinutes(1) });

        if (boxDefinition == null)
        {
            Workflow.Logger.Error("Box definition not found: {BoxId}", boxId);
            return;
        }

        // Start box workflow
        var workflowId = $"{boxId}-{Workflow.UtcNow:yyyyMMddHHmmss}";
        
        var childWorkflow = await Workflow.StartChildWorkflowAsync(
            "BoxWorkflow",
            new object[] { boxDefinition },
            new()
            {
                Id = workflowId,
                TaskQueue = "autosys-replacement-queue",
                WorkflowExecutionTimeout = boxDefinition.MaxDuration
            });

        _runningWorkflows[boxId] = workflowId;
        
        Workflow.Logger.Info("Started box workflow: {WorkflowId} for box: {BoxId}, Reason: {Reason}", 
            workflowId, boxId, reason);
    }

    private async Task CleanupCompletedWorkflows()
    {
        var completedBoxes = new List<string>();

        foreach (var (boxId, workflowId) in _runningWorkflows)
        {
            try
            {
                // Check if workflow is still running
                var isRunning = await Workflow.ExecuteActivityAsync(
                    "IsWorkflowRunningAsync",
                    new object[] { workflowId },
                    new() { StartToCloseTimeout = TimeSpan.FromSeconds(30) });

                if (!isRunning)
                {
                    completedBoxes.Add(boxId);
                }
            }
            catch (Exception ex)
            {
                Workflow.Logger.Warning(ex, "Error checking workflow status: {WorkflowId}", workflowId);
                // Assume completed if we can't check status
                completedBoxes.Add(boxId);
            }
        }

        foreach (var boxId in completedBoxes)
        {
            _runningWorkflows.Remove(boxId);
        }
    }

    private async Task CancelRunningWorkflow(string boxId)
    {
        if (_runningWorkflows.TryGetValue(boxId, out var workflowId))
        {
            try
            {
                await Workflow.ExecuteActivityAsync(
                    "CancelWorkflowAsync",
                    new object[] { workflowId },
                    new() { StartToCloseTimeout = TimeSpan.FromMinutes(1) });

                Workflow.Logger.Info("Cancelled running workflow: {WorkflowId} for box: {BoxId}", workflowId, boxId);
                _runningWorkflows.Remove(boxId);
            }
            catch (Exception ex)
            {
                Workflow.Logger.Error(ex, "Failed to cancel workflow: {WorkflowId}", workflowId);
            }
        }
    }
}
```

---

## Enhanced Activities

### File: src/AutoSys.Activities/AutoSys.Activities.csproj
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net7.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Temporalio" Version="1.0.0" />
    <PackageReference Include="System.Data.SqlClient" Version="4.8.5" />
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AutoSys.Models\AutoSys.Models.csproj" />
    <ProjectReference Include="..\ConsoleExecutor.Activities\ConsoleExecutor.Activities.csproj" />
  </ItemGroup>
</Project>
```

### File: src/AutoSys.Activities/BoxManagementActivities.cs
```csharp
using AutoSys.Models;
using Temporalio.Activities;
using System.Text.Json;

namespace AutoSys.Activities;

/// <summary>
/// Activities for managing box definitions and execution
/// </summary>
public static class BoxManagementActivities
{
    // In a real implementation, this would connect to a database
    private static readonly Dictionary<string, BoxDefinition> _boxDefinitions = new();

    [Activity]
    public static async Task<BoxDefinition?> GetBoxDefinitionAsync(string boxId)
    {
        var context = ActivityExecutionContext.Current;
        context.Logger.Info("Retrieving box definition: {BoxId}", boxId);

        // In real implementation, load from database
        if (_boxDefinitions.TryGetValue(boxId, out var boxDefinition))
        {
            return boxDefinition;
        }

        // Try loading from file system (for demo)
        var filePath = $"/app/box-definitions/{boxId}.json";
        if (File.Exists(filePath))
        {
            var json = await File.ReadAllTextAsync(filePath);
            var definition = JsonSerializer.Deserialize<BoxDefinition>(json);
            if (definition != null)
            {
                _boxDefinitions[boxId] = definition;
                return definition;
            }
        }

        context.Logger.Warning("Box definition not found: {BoxId}", boxId);
        return null;
    }

    [Activity]
    public static async Task SaveBoxDefinitionAsync(BoxDefinition boxDefinition)
    {
        var context = ActivityExecutionContext.Current;
        context.Logger.Info("Saving box definition: {BoxId}", boxDefinition.BoxId);

        // Save to memory cache
        _boxDefinitions[boxDefinition.BoxId] = boxDefinition;

        // Save to file system (for demo)
        var directory = "/app/box-definitions";
        Directory.CreateDirectory(directory);
        
        var filePath = Path.Combine(directory, $"{boxDefinition.BoxId}.json");
        var json = JsonSerializer.Serialize(boxDefinition, new JsonSerializerOptions 
        { 
            WriteIndented = true 
        });
        
        await File.WriteAllTextAsync(filePath, json);
        
        context.Logger.Info("Box definition saved: {BoxId}", boxDefinition.BoxId);
    }

    [Activity]
    public static async Task<bool> IsWorkflowRunningAsync(string workflowId)
    {
        var context = ActivityExecutionContext.Current;
        
        try
        {
            // This would use the Temporal client to check workflow status
            // For demo purposes, we'll simulate this
            await Task.Delay(100); // Simulate API call
            
            // In real implementation:
            // var client = GetTemporalClient();
            // var handle = client.GetWorkflowHandle(workflowId);
            // var description = await handle.DescribeAsync();
            // return description.Status == WorkflowExecutionStatus.Running;
            
            return false; // Assume completed for demo
        }
        catch (Exception ex)
        {
            context.Logger.Error(ex, "Error checking workflow status: {WorkflowId}", workflowId);
            return false;
        }
    }

    [Activity]
    public static async Task CancelWorkflowAsync(string workflowId)
    {
        var context = ActivityExecutionContext.Current;
        context.Logger.Info("Cancelling workflow: {WorkflowId}", workflowId);

        try
        {
            // In real implementation:
            // var client = GetTemporalClient();
            // var handle = client.GetWorkflowHandle(workflowId);
            // await handle.CancelAsync();
            
            await Task.Delay(100); // Simulate cancellation
            context.Logger.Info("Workflow cancelled: {WorkflowId}", workflowId);
        }
        catch (Exception ex)
        {
            context.Logger.Error(ex, "Failed to cancel workflow: {WorkflowId}", workflowId);
            throw;
        }
    }
}
```

### File: src/AutoSys.Activities/ConditionEvaluationActivities.cs
```csharp
using AutoSys.Models;
using Temporalio.Activities;
using System.Data.SqlClient;

namespace AutoSys.Activities;

/// <summary>
/// Activities for evaluating job conditions (replaces AutoSys conditions)
/// </summary>
public static class ConditionEvaluationActivities
{
    [Activity]
    public static async Task<bool> EvaluateJobConditionAsync(JobCondition condition)
    {
        var context = ActivityExecutionContext.Current;
        context.Logger.Info("Evaluating condition: {ConditionType} - {Expression}", 
            condition.Type, condition.Expression);

        try
        {
            return condition.Type switch
            {
                ConditionType.FileExists => await EvaluateFileExistsCondition(condition),
                ConditionType.FileSize => await EvaluateFileSizeCondition(condition),
                ConditionType.TimeWindow => await EvaluateTimeWindowCondition(condition),
                ConditionType.DatabaseQuery => await EvaluateDatabaseQueryCondition(condition),
                ConditionType.ApiCall => await EvaluateApiCallCondition(condition),
                ConditionType.Custom => await EvaluateCustomCondition(condition),
                _ => throw new NotSupportedException($"Condition type not supported: {condition.Type}")
            };
        }
        catch (Exception ex)
        {
            context.Logger.Error(ex, "Error evaluating condition: {ConditionType}", condition.Type);
            return false;
        }
    }

    private static async Task<bool> EvaluateFileExistsCondition(JobCondition condition)
    {
        var filePath = condition.Expression;
        
        // Support environment variable expansion
        filePath = Environment.ExpandEnvironmentVariables(filePath);
        
        // Support parameters for dynamic paths
        if (condition.Parameters.ContainsKey("date"))
        {
            var date = condition.Parameters["date"].ToString();
            filePath = filePath.Replace("{DATE}", date);
        }
        
        return File.Exists(filePath);
    }

    private static async Task<bool> EvaluateFileSizeCondition(JobCondition condition)
    {
        var parts = condition.Expression.Split('|');
        if (parts.Length != 2)
            return false;

        var filePath = parts[0];
        var minSizeBytes = long.Parse(parts[1]);

        if (!File.Exists(filePath))
            return false;

        var fileInfo = new FileInfo(filePath);
        return fileInfo.Length >= minSizeBytes;
    }

    private static async Task<bool> EvaluateTimeWindowCondition(JobCondition condition)
    {
        var parts = condition.Expression.Split('-');
        if (parts.Length != 2)
            return false;

        var startTime = TimeSpan.Parse(parts[0]);
        var endTime = TimeSpan.Parse(parts[1]);
        var currentTime = DateTime.Now.TimeOfDay;

        if (startTime <= endTime)
        {
            // Same day window
            return currentTime >= startTime && currentTime <= endTime;
        }
        else
        {
            // Overnight window
            return currentTime >= startTime || currentTime <= endTime;
        }
    }

    private static async Task<bool> EvaluateDatabaseQueryCondition(JobCondition condition)
    {
        if (!condition.Parameters.ContainsKey("connectionString"))
            return false;

        var connectionString = condition.Parameters["connectionString"].ToString();
        var query = condition.Expression;

        using var connection = new SqlConnection(connectionString);
        await connection.OpenAsync();

        using var command = new SqlCommand(query, connection);
        var result = await command.ExecuteScalarAsync();

        // Convert result to boolean
        return result switch
        {
            bool boolResult => boolResult,
            int intResult => intResult > 0,
            long longResult => longResult > 0,
            string stringResult => !string.IsNullOrEmpty(stringResult) && stringResult.ToLower() != "false",
            _ => result != null
        };
    }

    private static async Task<bool> EvaluateApiCallCondition(JobCondition condition)
    {
        using var httpClient = new HttpClient();
        
        var url = condition.Expression;
        
        // Add headers if specified
        if (condition.Parameters.ContainsKey("headers"))
        {
            var headers = condition.Parameters["headers"] as Dictionary<string, object>;
            if (headers != null)
            {
                foreach (var header in headers)
                {
                    httpClient.DefaultRequestHeaders.Add(header.Key, header.Value.ToString());
                }
            }
        }

        try
        {
            var response = await httpClient.GetAsync(url);
            
            // Check expected status code
            if (condition.Parameters.ContainsKey("expectedStatusCode"))
            {
                var expectedCode = (int)condition.Parameters["expectedStatusCode"];
                return (int)response.StatusCode == expectedCode;
            }

            return response.IsSuccessStatusCode;
        }
        catch
        {
            return false;
        }
    }

    private static async Task<bool> EvaluateCustomCondition(JobCondition condition)
    {
        // Execute custom condition script/executable
        var scriptPath = condition.Expression;
        
        if (!File.Exists(scriptPath))
            return false;

        try
        {
            var process = new System.Diagnostics.Process
            {
                StartInfo = new System.Diagnostics.ProcessStartInfo
                {
                    FileName = scriptPath,
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    CreateNoWindow = true
                }
            };

            // Add parameters as arguments
            if (condition.Parameters.Any())
            {
                var args = string.Join(" ", condition.Parameters.Select(p => $"--{p.Key} {p.Value}"));
                process.StartInfo.Arguments = args;
            }

            process.Start();
            await process.WaitForExitAsync();

            // Return true if exit code is 0
            return process.ExitCode == 0;
        }
        catch
        {
            return false;
        }
    }
}
```

---

## Management API and Web Interface

### File: src/AutoSys.Web/AutoSys.Web.csproj
```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net7.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Temporalio" Version="1.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AutoSys.Models\AutoSys.Models.csproj" />
    <ProjectReference Include="..\AutoSys.Activities\AutoSys.Activities.csproj" />
  </ItemGroup>
</Project>
```

### File: src/AutoSys.Web/Controllers/BoxController.cs
```csharp
using AutoSys.Models;
using Microsoft.AspNetCore.Mvc;
using Temporalio.Client;

namespace AutoSys.Web.Controllers;

[ApiController]
[Route("api/[controller]")]
public class BoxController : ControllerBase
{
    private readonly ITemporalClient _temporalClient;
    private readonly ILogger<BoxController> _logger;

    public BoxController(ITemporalClient temporalClient, ILogger<BoxController> logger)
    {
        _temporalClient = temporalClient;
        _logger = logger;
    }

    [HttpPost]
    public async Task<IActionResult> CreateBox([FromBody] BoxDefinition boxDefinition)
    {
        try
        {
            // Save box definition
            await _temporalClient.ExecuteActivityAsync(
                "SaveBoxDefinitionAsync",
                new object[] { boxDefinition },
                new() { TaskQueue = "autosys-replacement-queue" });

            return Ok(new { Message = "Box created successfully", BoxId = boxDefinition.BoxId });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating box: {BoxId}", boxDefinition.BoxId);
            return StatusCode(500, new { Error = ex.Message });
        }
    }

    [HttpGet("{boxId}")]
    public async Task<IActionResult> GetBox(string boxId)
    {
        try
        {
            var boxDefinition = await _temporalClient.ExecuteActivityAsync(
                "GetBoxDefinitionAsync",
                new object[] { boxId },
                new() { TaskQueue = "autosys-replacement-queue" });

            if (boxDefinition == null)
                return NotFound(new { Message = $"Box not found: {boxId}" });

            return Ok(boxDefinition);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving box: {BoxId}", boxId);
            return StatusCode(500, new { Error = ex.Message });
        }
    }

    [HttpPost("{boxId}/run")]
    public async Task<IActionResult> RunBox(string boxId, [FromBody] RunBoxRequest? request = null)
    {
        try
        {
            var boxDefinition = await _temporalClient.ExecuteActivityAsync(
                "GetBoxDefinitionAsync",
                new object[] { boxId },
                new() { TaskQueue = "autosys-replacement-queue" });

            if (boxDefinition == null)
                return NotFound(new { Message = $"Box not found: {boxId}" });

            var workflowId = $"{boxId}-{DateTime.UtcNow:yyyyMMddHHmmss}";
            if (!string.IsNullOrEmpty(request?.WorkflowId))
            {
                workflowId = request.WorkflowId;
            }

            var handle = await _temporalClient.StartWorkflowAsync(
                "BoxWorkflow",
                new object[] { boxDefinition },
                new WorkflowOptions(workflowId, "autosys-replacement-queue")
                {
                    WorkflowExecutionTimeout = boxDefinition.MaxDuration
                });

            return Ok(new 
            { 
                Message = "Box execution started",
                WorkflowId = workflowId,
                BoxId = boxId
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error running box: {BoxId}", boxId);
            return StatusCode(500, new { Error = ex.Message });
        }
    }

    [HttpGet("{boxId}/status/{workflowId}")]
    public async Task<IActionResult> GetBoxStatus(string boxId, string workflowId)
    {
        try
        {
            var handle = _temporalClient.GetWorkflowHandle(workflowId);
            var summary = await handle.QueryAsync("GetExecutionSummary");
            
            return Ok(summary);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting box status: {BoxId}, {WorkflowId}", boxId, workflowId);
            return StatusCode(500, new { Error = ex.Message });
        }
    }

    [HttpPost("{boxId}/cancel/{workflowId}")]
    public async Task<IActionResult> CancelBox(string boxId, string workflowId)
    {
        try
        {
            var handle = _temporalClient.GetWorkflowHandle(workflowId);
            await handle.SignalAsync("CancelExecution");
            
            return Ok(new { Message = "Box cancellation requested", WorkflowId = workflowId });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error cancelling box: {BoxId}, {WorkflowId}", boxId, workflowId);
            return StatusCode(500, new { Error = ex.Message });
        }
    }
}

public record RunBoxRequest
{
    public string? WorkflowId { get; init; }
    public Dictionary<string, string>? Parameters { get; init; }
}
```

### Simple Box Definition
```csharp
var dailyProcessingBox = new BoxDefinition
{
    BoxId = "DAILY_PROCESSING",
    Name = "Daily Data Processing",
    Description = "Processes daily transaction data",
    Jobs = new List<JobDefinition>
    {
        new()
        {
            JobId = "EXTRACT_DATA",
            Name = "Extract Data",
            ExecutionParameters = new ConsoleAppParameters
            {
                ExecutablePath = "/app/console-apps/DataExtractor.exe",
                Arguments = "--date {TODAY} --output /shared/extracted",
                TimeoutSeconds = 1800
            }
        },
        new()
        {
            JobId = "TRANSFORM_DATA",
            Name = "Transform Data", 
            Dependencies = new List<string> { "EXTRACT_DATA" },
            ExecutionParameters = new ConsoleAppParameters
            {
                ExecutablePath = "/app/console-apps/DataTransformer.exe",
                Arguments = "--input /shared/extracted --output /shared/transformed",
                TimeoutSeconds = 3600
            }
        },
        new()
        {
            JobId = "LOAD_DATA",
            Name = "Load Data to Database",
            Dependencies = new List<string> { "TRANSFORM_DATA" },
            ExecutionParameters = new ConsoleAppParameters
            {
                ExecutablePath = "python",
                Arguments = "/app/console-apps/data_loader.py --input /shared/transformed",
                TimeoutSeconds = 2400
            }
        }
    },
    FailureHandling = FailureHandling.StopBox,
    Notifications = new NotificationSettings
    {
        EmailAddresses = new List<string> { "data-team@company.com" },
        Triggers = new NotificationTriggers
        {
            OnSuccess = true,
            OnFailure = true
        }
    }
};
```

### Running a Box
```csharp
// Start the box workflow
var boxWorkflowId = $"daily-processing-{DateTime.Now:yyyyMMdd}";
var handle = await client.StartWorkflowAsync(
    "BoxWorkflow",
    new object[] { dailyProcessingBox },
    new WorkflowOptions(boxWorkflowId, "autosys-replacement-queue")
    {
        WorkflowExecutionTimeout = dailyProcessingBox.MaxDuration
    });

// Monitor progress
var summary = await handle.QueryAsync("GetExecutionSummary");
Console.WriteLine($"Box {summary.BoxId}: {summary.Status} - {summary.CompletedJobs}/{summary.TotalJobs} jobs completed");
```

This framework gives you:

✅ **AutoSys Box → Temporal Workflow mapping**  
✅ **Job Dependencies** handled through workflow logic  
✅ **Parallel and Sequential** job execution  
✅ **Failure Handling** strategies  
✅ **Real-time Monitoring** through queries  
✅ **Pause/Resume/Cancel** capabilities  
✅ **Retry Policies** at box and job level  
✅ **Condition Evaluation** before job execution  
✅ **Post-job Actions** (notifications, etc.)  

Would you like me to continue with the scheduling component or focus on a specific aspect?